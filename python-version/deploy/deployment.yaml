apiVersion: apps/v1
kind: Deployment
metadata:
  name: nodeguardian-python
  namespace: nodeguardian-system
  labels:
    app.kubernetes.io/name: nodeguardian
    app.kubernetes.io/component: controller
    app.kubernetes.io/version: "1.0.0"
    app.kubernetes.io/implementation: "python"
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: nodeguardian
      app.kubernetes.io/component: controller
      app.kubernetes.io/implementation: "python"
  template:
    metadata:
      labels:
        app.kubernetes.io/name: nodeguardian
        app.kubernetes.io/component: controller
        app.kubernetes.io/version: "1.0.0"
        app.kubernetes.io/implementation: "python"
    spec:
      serviceAccountName: nodeguardian
      containers:
      - name: nodeguardian
        image: nodeguardian-python:latest
        imagePullPolicy: IfNotPresent
        ports:
        - name: http
          containerPort: 9115
          protocol: TCP
        env:
        - name: SHELL_OPERATOR_HOOKS_DIR
          value: "/app/hooks"
        - name: PYTHONPATH
          value: "/app/src"
        - name: NODEGUARDIAN_NAMESPACE
          value: "nodeguardian-system"
        - name: LOG_LEVEL
          value: "INFO"
        - name: PROMETHEUS_URL
          value: "http://prometheus-k8s.monitoring.svc:9090"
        - name: METRICS_SERVER_URL
          value: "https://kubernetes.default.svc:443/apis/metrics.k8s.io/v1beta1"
        # 告警配置
        - name: ALERT_EMAIL_SMTP
          value: "smtp.gmail.com:587"
        - name: ALERT_EMAIL_FROM
          value: "nodeguardian@example.com"
        - name: ALERT_EMAIL_TO
          value: "admin@example.com"
        - name: ALERT_SLACK_WEBHOOK
          value: ""
        - name: ALERT_WEBHOOK_URL
          value: ""
        resources:
          requests:
            memory: "256Mi"
            cpu: "200m"
          limits:
            memory: "1Gi"
            cpu: "1000m"
        livenessProbe:
          httpGet:
            path: /health
            port: http
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /health
            port: http
          initialDelaySeconds: 5
          periodSeconds: 5
          timeoutSeconds: 3
          failureThreshold: 3
        volumeMounts:
        - name: tmp
          mountPath: /tmp
        - name: hooks
          mountPath: /app/hooks
          readOnly: true
        - name: src
          mountPath: /app/src
          readOnly: true
      volumes:
      - name: tmp
        emptyDir: {}
      - name: hooks
        configMap:
          name: nodeguardian-hooks-python
          defaultMode: 0755
      - name: src
        configMap:
          name: nodeguardian-src
          defaultMode: 0755
      restartPolicy: Always
      terminationGracePeriodSeconds: 30

---
apiVersion: v1
kind: Service
metadata:
  name: nodeguardian-python
  namespace: nodeguardian-system
  labels:
    app.kubernetes.io/name: nodeguardian
    app.kubernetes.io/component: controller
    app.kubernetes.io/implementation: "python"
spec:
  type: ClusterIP
  ports:
  - name: http
    port: 9115
    targetPort: http
    protocol: TCP
  selector:
    app.kubernetes.io/name: nodeguardian
    app.kubernetes.io/component: controller
    app.kubernetes.io/implementation: "python"

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: nodeguardian-hooks-python
  namespace: nodeguardian-system
  labels:
    app.kubernetes.io/name: nodeguardian
    app.kubernetes.io/component: controller
    app.kubernetes.io/implementation: "python"
data:
  nodeguardian_controller.py: |
    #!/usr/bin/env python3
    """
    NodeGuardian Main Controller Hook
    监听NodeGuardianRule CRD变化并管理规则生命周期
    """
    
    import sys
    import json
    import os
    import time
    from typing import Dict, Any, List, Optional
    from pathlib import Path
    
    # Add src to path for imports
    sys.path.insert(0, str(Path(__file__).parent.parent / "src"))
    
    from nodeguardian.common import Logger, NodeGuardianConfig, load_config
    from nodeguardian.rule_engine import RuleEngine, Rule
    
    
    class NodeGuardianController:
        """Main controller for NodeGuardian."""
        
        def __init__(self):
            self.config = load_config()
            self.logger = Logger("nodeguardian-controller")
            self.rule_engine = RuleEngine(self.config)
            self.binding_context_path = os.getenv("BINDING_CONTEXT_PATH", "/tmp/binding_context.json")
        
        def get_hook_config(self) -> Dict[str, Any]:
            """Return hook configuration for shell-operator."""
            return {
                "configVersion": "v1",
                "onStartup": 1,
                "kubernetes": [
                    {
                        "name": "monitor-nodeguardian-rules",
                        "apiVersion": "nodeguardian.k8s.io/v1",
                        "kind": "NodeGuardianRule",
                        "executeHookOnEvent": ["Added", "Modified", "Deleted"],
                        "executeHookOnSynchronization": True,
                        "queue": "nodeguardian-rules"
                    },
                    {
                        "name": "monitor-alert-templates",
                        "apiVersion": "nodeguardian.k8s.io/v1",
                        "kind": "AlertTemplate",
                        "executeHookOnEvent": ["Added", "Modified", "Deleted"],
                        "executeHookOnSynchronization": True,
                        "queue": "nodeguardian-rules"
                    }
                ],
                "schedule": [
                    {
                        "name": "rule-evaluation",
                        "crontab": "*/1 * * * *",  # 每分钟执行一次
                        "queue": "rule-evaluation",
                        "includeSnapshotsFrom": ["monitor-nodeguardian-rules"]
                    }
                ],
                "settings": {
                    "executionMinInterval": "10s",
                    "executionBurst": 1
                }
            }
        
        def handle_startup(self) -> None:
            """Handle startup event."""
            self.logger.info("NodeGuardian controller starting up...")
            
            # Create necessary resources
            self._create_namespace_if_not_exists()
            self._create_configmap_if_not_exists()
            
            # Initialize all existing rules
            self._initialize_existing_rules()
            
            self.logger.info("NodeGuardian controller startup completed")
        
        def handle_synchronization(self, binding: str) -> None:
            """Handle synchronization event."""
            if binding == "monitor-nodeguardian-rules":
                self._handle_rules_synchronization()
            elif binding == "monitor-alert-templates":
                self._handle_templates_synchronization()
        
        def _handle_rules_synchronization(self) -> None:
            """Handle rules synchronization."""
            try:
                with open(self.binding_context_path, 'r') as f:
                    context = json.load(f)
                
                objects = context[0].get("objects", [])
                self.logger.info(f"Synchronizing {len(objects)} NodeGuardianRule objects")
                
                for obj in objects:
                    rule_object = obj["object"]
                    rule_name = rule_object["metadata"]["name"]
                    rule_enabled = rule_object.get("spec", {}).get("metadata", {}).get("enabled", True)
                    
                    if rule_enabled:
                        self._register_rule(rule_object)
                    else:
                        self._unregister_rule(rule_name)
            except Exception as e:
                self.logger.error(f"Failed to handle rules synchronization: {e}")
        
        def _handle_templates_synchronization(self) -> None:
            """Handle templates synchronization."""
            try:
                with open(self.binding_context_path, 'r') as f:
                    context = json.load(f)
                
                objects = context[0].get("objects", [])
                self.logger.info(f"Synchronizing {len(objects)} AlertTemplate objects")
                
                for obj in objects:
                    template_object = obj["object"]
                    template_name = template_object["metadata"]["name"]
                    self._register_alert_template(template_object)
            except Exception as e:
                self.logger.error(f"Failed to handle templates synchronization: {e}")
        
        def handle_event(self, binding: str, watch_event: str, object_data: Dict[str, Any]) -> None:
            """Handle Kubernetes event."""
            if binding == "monitor-nodeguardian-rules":
                self._handle_rule_event(watch_event, object_data)
            elif binding == "monitor-alert-templates":
                self._handle_template_event(watch_event, object_data)
        
        def _handle_rule_event(self, watch_event: str, rule_object: Dict[str, Any]) -> None:
            """Handle rule event."""
            rule_name = rule_object["metadata"]["name"]
            self.logger.info(f"Processing rule event: {watch_event} for rule: {rule_name}")
            
            if watch_event in ["Added", "Modified"]:
                rule_enabled = rule_object.get("spec", {}).get("metadata", {}).get("enabled", True)
                if rule_enabled:
                    self._register_rule(rule_object)
                else:
                    self._unregister_rule(rule_name)
            elif watch_event == "Deleted":
                self._unregister_rule(rule_name)
        
        def _handle_template_event(self, watch_event: str, template_object: Dict[str, Any]) -> None:
            """Handle template event."""
            template_name = template_object["metadata"]["name"]
            self.logger.info(f"Processing template event: {watch_event} for template: {template_name}")
            
            if watch_event in ["Added", "Modified"]:
                self._register_alert_template(template_object)
            elif watch_event == "Deleted":
                self._unregister_alert_template(template_name)
        
        def handle_schedule(self, binding: str) -> None:
            """Handle schedule event."""
            if binding == "rule-evaluation":
                self._evaluate_all_rules()
        
        def _register_rule(self, rule_object: Dict[str, Any]) -> None:
            """Register a rule."""
            rule_name = rule_object["metadata"]["name"]
            check_interval = rule_object.get("spec", {}).get("monitoring", {}).get("checkInterval", "60s")
            
            self.logger.info(f"Registering rule: {rule_name} with check interval: {check_interval}")
            
            try:
                rule = self.rule_engine.load_rule(rule_object)
                self.rule_engine.save_rule(rule)
                
                # Update status
                self.rule_engine.k8s_client.update_rule_status(rule_name, "Active", "", [])
                
                self.logger.info(f"Rule registered: {rule_name}")
            except Exception as e:
                self.logger.error(f"Failed to register rule {rule_name}: {e}")
        
        def _unregister_rule(self, rule_name: str) -> None:
            """Unregister a rule."""
            self.logger.info(f"Unregistering rule: {rule_name}")
            
            try:
                self.rule_engine.delete_rule(rule_name)
                
                # Update status
                self.rule_engine.k8s_client.update_rule_status(rule_name, "Inactive", "Rule deleted", [])
                
                self.logger.info(f"Rule unregistered: {rule_name}")
            except Exception as e:
                self.logger.error(f"Failed to unregister rule {rule_name}: {e}")
        
        def _register_alert_template(self, template_object: Dict[str, Any]) -> None:
            """Register an alert template."""
            template_name = template_object["metadata"]["name"]
            
            self.logger.info(f"Registering alert template: {template_name}")
            
            try:
                # Save template to file
                template_file = f"/tmp/nodeguardian/templates/{template_name}.json"
                os.makedirs(os.path.dirname(template_file), exist_ok=True)
                
                with open(template_file, 'w') as f:
                    json.dump(template_object, f, indent=2, ensure_ascii=False)
                
                self.logger.info(f"Alert template registered: {template_name}")
            except Exception as e:
                self.logger.error(f"Failed to register alert template {template_name}: {e}")
        
        def _unregister_alert_template(self, template_name: str) -> None:
            """Unregister an alert template."""
            self.logger.info(f"Unregistering alert template: {template_name}")
            
            try:
                # Delete template file
                template_file = f"/tmp/nodeguardian/templates/{template_name}.json"
                if os.path.exists(template_file):
                    os.remove(template_file)
                
                self.logger.info(f"Alert template unregistered: {template_name}")
            except Exception as e:
                self.logger.error(f"Failed to unregister alert template {template_name}: {e}")
        
        def _evaluate_all_rules(self) -> None:
            """Evaluate all active rules."""
            self.logger.debug("Evaluating all active rules...")
            self.rule_engine.evaluate_all_rules()
        
        def _create_namespace_if_not_exists(self) -> None:
            """Create namespace if it doesn't exist."""
            try:
                self.rule_engine.k8s_client.v1.read_namespace(name=self.config.namespace)
            except Exception:
                self.logger.info(f"Creating namespace: {self.config.namespace}")
                from kubernetes.client import V1Namespace, V1ObjectMeta
                namespace = V1Namespace(metadata=V1ObjectMeta(name=self.config.namespace))
                self.rule_engine.k8s_client.v1.create_namespace(body=namespace)
        
        def _create_configmap_if_not_exists(self) -> None:
            """Create configmap if it doesn't exist."""
            try:
                self.rule_engine.k8s_client.v1.read_namespaced_config_map(
                    name="nodeguardian-config",
                    namespace=self.config.namespace
                )
            except Exception:
                self.logger.info("Creating configmap: nodeguardian-config")
                from kubernetes.client import V1ConfigMap, V1ObjectMeta
                configmap = V1ConfigMap(
                    metadata=V1ObjectMeta(name="nodeguardian-config"),
                    data={
                        "prometheus_url": self.config.prometheus_url,
                        "metrics_server_url": self.config.metrics_server_url,
                        "log_level": self.config.log_level
                    }
                )
                self.rule_engine.k8s_client.v1.create_namespaced_config_map(
                    namespace=self.config.namespace,
                    body=configmap
                )
        
        def _initialize_existing_rules(self) -> None:
            """Initialize all existing rules."""
            self.logger.info("Initializing existing NodeGuardianRule objects...")
            # This will be handled in synchronization phase
            pass
        
        def process_binding_context(self) -> None:
            """Process binding context from shell-operator."""
            try:
                if not os.path.exists(self.binding_context_path):
                    self.logger.error(f"Binding context file not found: {self.binding_context_path}")
                    return
                
                with open(self.binding_context_path, 'r') as f:
                    context = json.load(f)
                
                if not context:
                    self.logger.error("Empty binding context")
                    return
                
                context_type = context[0].get("type")
                binding = context[0].get("binding")
                
                self.logger.info(f"Processing binding context: type={context_type}, binding={binding}")
                
                if context_type == "onStartup":
                    self.handle_startup()
                elif context_type == "Synchronization":
                    self.handle_synchronization(binding)
                elif context_type == "Event":
                    watch_event = context[0].get("watchEvent")
                    object_data = context[0].get("object", {})
                    self.handle_event(binding, watch_event, object_data)
                elif context_type == "Schedule":
                    self.handle_schedule(binding)
                else:
                    self.logger.warning(f"Unknown binding context type: {context_type}")
            except Exception as e:
                self.logger.error(f"Failed to process binding context: {e}")
                raise
    
    
    def main():
        """Main entry point."""
        if len(sys.argv) > 1 and sys.argv[1] == "--config":
            # Return hook configuration
            controller = NodeGuardianController()
            config = controller.get_hook_config()
            print(json.dumps(config, indent=2))
            return
        
        # Process binding context
        controller = NodeGuardianController()
        controller.logger.info("NodeGuardian controller hook started")
        
        try:
            controller.process_binding_context()
            controller.logger.info("NodeGuardian controller hook completed")
        except Exception as e:
            controller.logger.error(f"NodeGuardian controller hook failed: {e}")
            sys.exit(1)
    
    
    if __name__ == "__main__":
        main()

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: nodeguardian-src
  namespace: nodeguardian-system
  labels:
    app.kubernetes.io/name: nodeguardian
    app.kubernetes.io/component: controller
    app.kubernetes.io/implementation: "python"
data:
  nodeguardian/__init__.py: |
    """NodeGuardian - Event-driven Kubernetes node self-healing tool."""
    
    __version__ = "1.0.0"
    __author__ = "NodeGuardian Team"
    __email__ = "team@nodeguardian.io"
